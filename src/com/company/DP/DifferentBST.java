package com.company.DP;

/**
 * 题目描述:
 * 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
 *
 *
 * 解题思路:
 * 长度为n的序列(1,2,3,4,5,6,...,n)
 *    小循环的内核:
 *      遍历每次选择一个节点 j 作为根结点,从根结点 j 左右分为两个区间.(需要注意的是左右两个区间都是连续的)
 *      左区间形成的左子树种类 + 右区间形成的右子树种类 = 以 j 为根结点形成的树的数量
 *      分治+动态
 *    大循环的内核:
 *      记录序列(1,2,3,4,...,i)的结果,将其存入dp[]当中,往后的计算需要用到.
 *      类似滚雪球,从序列的最前端开始滚,慢慢滚到最长.
 *
 * 所以最终结果是dp[]滚到最后的值
 *      基础解: 空树 == 1
 *             一个节点 == 1
 *
 *
 *关键在于:固定长度 i 的连续子序列所形成的子树种类相同.
 */
public class DifferentBST {

    public int numTrees(int n){

        //0位要存储左子树为空的情况,所以长度+1
        int[] dp = new int[n+1];

        dp[0] = 1;
        dp[1] = 1;

        for (int i = 2;i <= n;i++)
            for (int j = 0;j < i;j++)
                dp[i] += dp[j] * dp[i-j-1];

        return dp[n];
    }
}
